------------------------------------
Active consideration:
- pattern matching
    - support JSONPath as attribute addresses
    - add aliases to use the same event name in different sets and later address it
    - AND/OR expressions in where-clauses
    - compare general functionality to RegExp and confirm parity
        - alternatives: event1{1,2} or b{2,3} (events in the set are AND)
        - any event BUT event1
    - pre-emptive runner/automaton/buffers
- db
    - come up with a design for exploring matched sequences. After the pattern match, how can we process the sequences of events?
    - db for attributes/events
        - dynamic schema detection?
        - if the schema is known (trained) during the acceptance of events, we can re-generate the automaton to use specific types and thus make it faster (a-la JIT)
            - or at least switch to typed db (and thus improve disk space and filtering speed)


------------------------------------
Other Ideas (nned review):
- JSONPath
- it can collect stats per set/event and report how often it matched (even if the automaton failed) (100% matches for first set/event, then compared to that ...)





------------------------------------
Notes:
- all numbers are floats
- it assumes all time stamps are in NANOSECONDS
- it assumes events are ordered in time
- "event a then <window> event b" - window is calculated from the last matched event in the previous set
- window expression can contain relative dates ("window from last week to today"). Actual dates should be resolved at run-time.
    However, an automaton can live for days and thus old captured events might become invalid. So the automaton should be able
    to confirm it's state by replaying captured events (a.Replay() *automaton). A new instance of an automaton is created and events are fed to it.
    The caller then may remove automatons which become invalid due to relative window values.
